#include <Arduino.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#include <string>

#ifdef ARDUINO_ARCH_RP2040
using GenericSPIClass = SPIClassRP2040;
#elif defined(ARDUINO_ARCH_ESP32)
using GenericSPIClass = SPIClass;
#endif

using byte = unsigned char;

#ifdef ARDUINO_ARCH_RP2040
const int SPI_MOSI = 5;
const int SPI_MISO = 6;
const int SPI_CLK = 4;
const int SPI_CS = 7;
#elif defined(ARDUINO_ARCH_ESP32)
const int SPI_MOSI = 23;
const int SPI_MISO = 19;
const int SPI_CLK = 18;
const int SPI_CS = 5;
#endif
const int SPI_frequency = 1000000; // absolute max is 10MHz, but use 1MHz to be safe.
const SPISettings default_SPI_settings(SPI_frequency, MSBFIRST, SPI_MODE1); // Mode: Shift on clock rise, sample on clock fall, clock idle is low.

#ifdef ARDUINO_ARCH_RP2040
const int nSLEEP = 10;
const int DRVOFF = 8;
const int nFAULT = 16;
const int IN1 = 19;
const int IN2 = 20;
#elif defined(ARDUINO_ARCH_ESP32)
const int nSLEEP = 15;
const int DRVOFF = 17;
const int nFAULT = 4;
const int IN1 = 16;
const int IN2 = 13;
#endif

#ifdef ARDUINO_ARCH_RP2040
const int internal_LED = 25;
#elif defined(ARDUINO_ARCH_ESP32)
const int internal_LED = 2;
#endif

// Bitmasks for standard frame responses
const byte status_fault_bitmask = 0b00100000;
const byte status_overvoltage_bitmask = 0b00010000;
const byte status_undervoltage_bitmask = 0b00001000;
const byte status_overcurrent_bitmask = 0b00000100;
const byte status_overtemperature_bitmask = 0b00000010;
const byte status_spi_error_bitmask = 0b00000001;

// Register addresses
const byte DEVICE_ID_addr = 0x00;
const byte FAULT_SUMMARY_addr = 0x01;
const byte STATUS1_addr = 0x02;
const byte STATUS2_addr = 0x03;
const byte COMMAND_addr = 0x08;
const byte SPI_IN_addr = 0x09;
const byte CONFIG1_addr = 0x0A;
const byte CONFIG2_addr = 0x0B;
const byte CONFIG3_addr = 0x0C;
const byte CONFIG4_addr = 0x0D;

// screen params
const int screen_width = 128;
const int screen_height = 64;
const int screen_sda = 0;
const int screen_sdl = 1;
const int text_size = 1;
const int text_colour = WHITE;

enum class Operation {
  write = 0, // as specified in datasheet. DO NOT CHANGE.
  read = 1
};

struct CommandResponse {
  bool fault = false;
  bool overvoltage = false;
  bool undervoltage = false;
  bool overcurrent = false;
  bool overtemperature = false;
  bool spi_error = false;
  byte report = 0x00;
  byte status = 0x00;
};

enum class DriverDirection {
  out1,
  out2,
  off
};

DriverDirection direction = DriverDirection::out1;

byte null_byte = 0b00000000;

CommandResponse send_command(Operation operation, byte address, byte data = null_byte, GenericSPIClass &spi = SPI, const SPISettings &spi_settings = default_SPI_settings);
void stall_mcu(void) {
  while (true) {};
}

Adafruit_SSD1306 display(screen_width, screen_height, &Wire, -1, 400000UL, 100000UL);

void print_screen(std::string text, bool flush = false) {
  if (flush) {
    display.setCursor(0, 0);
    display.clearDisplay();
  }
  Serial.println(text.c_str());
  display.println(text.c_str());
  display.display();
  return;
}

void print_screen_hex(uint8_t data, bool flush = true) {
  if (flush) {
    display.setCursor(0, 0);
    display.clearDisplay();
  }
  Serial.println(data, HEX);
  display.println(data, HEX);
  display.display();
  return;
}

void print_screen_hex(uint16_t data, bool flush = true) {
  if (flush) {
    display.setCursor(0, 0);
    display.clearDisplay();
  }
  Serial.println(data, HEX);
  display.println(data, HEX);
  display.display();
  return;
}

void setup() {
  Serial.begin(115200);
  delay(5000);

  Serial.println("Beginning setup");

  Wire.begin();

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("SSD1306 allocation failed");
    stall_mcu();
  }
  Serial.println("SSD1306 allocation successful");

  display.display();
  Serial.println("initial display");
  delay(2000);
  display.clearDisplay();
  Serial.println("cleared initial display");

  display.setTextSize(text_size);
  display.setTextColor(text_colour);
  display.setCursor(0, 0);
  display.println("Hello world");
  display.println("funny");
  display.display();
  delay(5000);
  display.clearDisplay();

  // setup pin modes
  print_screen("Setting up pin modes", false);
  pinMode(SPI_CS, OUTPUT);
  pinMode(nSLEEP, OUTPUT);
  pinMode(DRVOFF, OUTPUT);
  pinMode(nFAULT, INPUT);
  pinMode(IN1, OUTPUT); // these should be PWM but do later
  pinMode(IN2, OUTPUT);
  pinMode(internal_LED, OUTPUT);
  print_screen("Set up pin modes", false);

  // setup SPI
  print_screen("Setting up SPI", false);
  SPI.begin(SPI_CLK, SPI_MISO, SPI_MOSI, SPI_CS);
  // SPI.setMISO(SPI_MISO);
  // print_screen("Set up MISO");
  // SPI.setCS(SPI_CS);
  // print_screen("Set up SCS");
  // SPI.setSCK(SPI_CLK);
  // print_screen("Set up SCLK");
  // SPI.setMOSI(SPI_MOSI);
  // print_screen("Set up MOSI");
  // print_screen("Set SPI pins");
  // SPI.begin(true);
  print_screen("Set up SPI", false);

  delay(100); // make sure everything is intialised
  digitalWrite(internal_LED, HIGH);
  delay(5000);
  digitalWrite(internal_LED, LOW);
  
  // set pin states to prevent wacky things
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(SPI_CS, HIGH);

  /**
   * To configure the driver:
   * Set S_MODE bits in CONFIG3 register to 2'b10 or 2'b11 for PWM mode
   * nSLEEP high and DRVOFF low to set to active
   */

  digitalWrite(nSLEEP, HIGH);
  digitalWrite(DRVOFF, LOW);
  delay(100); // ensure driver has become active

  CommandResponse response = send_command(Operation::read, CONFIG3_addr);
  if (response.fault) {
    digitalWrite(internal_LED, HIGH);
    print_screen("Driver faulted! Stopping...", false);
    stall_mcu();
  }
  delay(2000);
  byte config3_value = response.report;
  config3_value = config3_value | 0b00000011; // set to PWM mode
  response = send_command(Operation::write, CONFIG3_addr, config3_value);
  if (response.fault) {
    digitalWrite(internal_LED, HIGH);
    print_screen("Driver faulted! Stopping...", false);
    stall_mcu();
  }
  delay(2000);

  print_screen("Finished setup", false);
}

void loop() {
  if (direction == DriverDirection::off) {
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
  }
  else if (direction == DriverDirection::out1) {
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
  }
  else if (direction == DriverDirection::out2) {
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);
  }
}

CommandResponse send_command(Operation operation, byte address, byte data, GenericSPIClass &spi, const SPISettings &spi_settings) {
  /**
   * Command byte (MSB to LSB):
   * - 0 (standard frame)
   * - operation: 1 for read, 0 for write
   * - address (6 bits)
   * 
   * Data byte:
   * - NULL if read
   */
  byte command_byte = 0b00000000 | (byte) operation << 6 | address;
  uint16_t command = ((uint16_t) command_byte) << 8 | ((uint16_t) data);
  print_screen_hex(command);

  spi.beginTransaction(spi_settings);
  uint16_t result = spi.transfer16(command);
  spi.endTransaction();

  byte status = (byte) (result >> 8);
  byte report = (byte) result;

  print_screen_hex(status);
  print_screen_hex(report, false);

  CommandResponse response;
  response.status = status;
  response.report = report;

  // check for errors
  if (status < 0b11000000) {
    print_screen(("Driver status not normal in " + std::string(__FUNCTION__)).c_str(), false);
    return response;
  }
  if (!(status && status_fault_bitmask)) {
    print_screen(("Driver command normal in " + std::string(__FUNCTION__)).c_str(), false);
    return response;
  }
  response.fault = true;
  if (status && status_overvoltage_bitmask) {
    print_screen(("Driver overvoltage detected in " + std::string(__FUNCTION__)).c_str(), false);
    response.overvoltage = true;
  }
  else if (status && status_undervoltage_bitmask) {
    print_screen(("Driver undervoltage detected in " + std::string(__FUNCTION__)).c_str(), false);
    response.undervoltage = true;
  }
  else if (status && status_overcurrent_bitmask) {
    print_screen(("Driver overcurrent detected in " + std::string(__FUNCTION__)).c_str(), false);
    response.overcurrent = true;
  }
  else if (status && status_overtemperature_bitmask) {
    print_screen(("Driver overtemperature detected in " + std::string(__FUNCTION__)).c_str(), false);
    response.overtemperature = true;
  }
  else if (status && status_spi_error_bitmask) {
    print_screen(("Driver SPI error detected in " + std::string(__FUNCTION__)).c_str(), false);
    response.spi_error = true;
  }
  else {
    print_screen(("Either driver open load or power-on-reset detected in " + std::string(__FUNCTION__)).c_str(), false);
  }

  return response;
}